# -*- coding: utf-8 -*-
"""new final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sVXa7W74I3AMiPzAJEAbJj9AMRwTmXDd
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

#Step 1 : load the dataset
refinal=pd.read_csv(r"/content/drive/MyDrive/Heart_disease_cleveland_new.csv")

# # Display first five rows
print(refinal.head())

#Display the number of columns and rows in refinal dataset
refinal.shape

#Display summary information
refinal.info()

#Display datatype of each column in the dataframe
print(refinal.dtypes)

#Display statistical summary of numerical features in the dataframe
refinal.describe()

#Generate statistic summary for the column contain float64 datatype
refinal.describe(include=['float64'])

## Check and display the number of missing values in each column
print(refinal.isnull().sum())

#Define the numerical continous data
num_continous_features=['age','trestbps','chol','thalach','oldpeak']

#Identify the attributes that need to be converted into object data type
convert_features=[feature for feature in refinal.columns if feature not in num_continous_features]

#Convert the identified attributes to object data type
refinal[convert_features]=refinal[convert_features].astype('object')

#Display the updated datatype
refinal.dtypes

#Display transposed summary statistics for numerical features
refinal.describe().T

#Generate summary statistics for categorical (object-type) features
refinal.describe(include='object')

"""EXPLORATORY DATA ANALYSIS (EDA)"""

refinal_continuous = refinal[num_continous_features]

# Set up the subplot
fig, ax = plt.subplots(nrows=2, ncols=3, figsize=(15, 10))

# Loop to plot histograms for each continuous feature
for i, col in enumerate(refinal_continuous.columns):
    x = i // 3
    y = i % 3
    values, bin_edges = np.histogram(refinal_continuous[col],
                                     range=(np.floor(refinal_continuous[col].min()), np.ceil(refinal_continuous[col].max())))

    graph = sns.histplot(data=refinal_continuous, x=col, bins=bin_edges, kde=True, ax=ax[x, y],
                         edgecolor='none', color='black', alpha=0.6, line_kws={'lw': 3})
    ax[x, y].set_xlabel(col, fontsize=15)
    ax[x, y].set_ylabel('Count', fontsize=12)
    ax[x, y].set_xticks(np.round(bin_edges, 1))
    ax[x, y].set_xticklabels(ax[x, y].get_xticks(), rotation=45)
    ax[x, y].grid(color='lightgrey')

    for j, p in enumerate(graph.patches):
        ax[x, y].annotate('{}'.format(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height() + 1),
                          ha='center', fontsize=10, fontweight="bold")
    #mean and std
    textstr = '\n'.join((
        r'$\mu=%.2f$' % refinal_continuous[col].mean(),
        r'$\sigma=%.2f$' % refinal_continuous[col].std()
    ))
    ax[x, y].text(0.75, 0.9, textstr, transform=ax[x, y].transAxes, fontsize=12, verticalalignment='top',
                  color='white', bbox=dict(boxstyle='round', facecolor='orange', edgecolor='white', pad=0.5))

ax[1,2].axis('off')
plt.suptitle('Distribution of Continuous Variables', fontsize=20)
plt.tight_layout()
plt.subplots_adjust(top=0.92)
plt.show()

categorical_features = refinal.columns.difference(num_continous_features)
refinal_categorical = refinal[categorical_features]
# Set up the subplot for a 4x2 layout
fig, ax = plt.subplots(nrows=5, ncols=2, figsize=(15, 18))

# Loop to plot bar charts for each categorical feature in the 4x2 layout
for i, col in enumerate(categorical_features):
    row = i // 2
    col_idx = i % 2

    # Calculate frequency percentages
    value_counts = refinal[col].value_counts(normalize=True).mul(100).sort_values()

    # Plot bar chart
    value_counts.plot(kind='barh', ax=ax[row, col_idx], width=0.8, color='red')

    # Add frequency percentages to the bars
    for index, value in enumerate(value_counts):
        ax[row, col_idx].text(value, index, str(round(value, 1)) + '%', fontsize=15, weight='bold', va='center')

    ax[row, col_idx].set_xlim([0, 95])
    ax[row, col_idx].set_xlabel('Frequency Percentage', fontsize=12)
    ax[row, col_idx].set_title(f'{col}', fontsize=20)

ax[4,1].axis('off')
plt.suptitle('Distribution of Categorical Variables', fontsize=22)
plt.tight_layout()
plt.subplots_adjust(top=0.95)
plt.show()

"""Bivariate Analysis"""

#Set figure size
plt.figure(figsize=(15, 10))

for i, feature in enumerate(num_continous_features):
    plt.subplot(2, 3, i + 1)

    # Create the boxplot
    ax = sns.boxplot(x='target', y=feature, data=refinal,color="green")
    plt.title(f'{feature} vs Target')

    # Calculate mean and count for each 'target' group
    target_groups = refinal.groupby('target')[feature]
    for target_value, group in target_groups:
        mean_val = group.mean()
        count_val = group.count()

        # Add annotations for mean and count on the boxplot
        ax.annotate(f'Mean: {mean_val:.2f}\nCount: {count_val}',
                    xy=(target_value, mean_val),
                    xycoords='data',
                    ha='center',
                    va='center',
                    fontsize=12,
                    color='black',
                    bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.5'))

plt.tight_layout()
#Display the output
plt.show()

#Copy of the orginal datset
cleaned_refinal = refinal.copy()

#Calculate Q!,Q# and IQR for the numerical continuous features
Q1 = refinal[num_continous_features].quantile(0.25)
Q3 = refinal[num_continous_features].quantile(0.75)
#Interquartile range
IQR = Q3 - Q1

#Identify outliners
finoutl=(cleaned_refinal[num_continous_features] < (Q1 - 1.5 * IQR))| (cleaned_refinal[num_continous_features] > (Q3 + 1.5 * IQR))
#Filter rows that have NO outliers in any of the specified features
remout=~(finoutl).any(axis=1)
#Count outliners in each continous_features
outliers_count_specified = (finoutl).sum()
#new dataftrame without otliners
cleaned_refinal1 = cleaned_refinal[remout]

# output
print("outliners count :",outliers_count_specified)
print("Original shape:", refinal.shape)
print("After outlier removal:", cleaned_refinal1.shape)

# List of categorical features
categorical_features = ['sex', 'cp', 'fbs', 'restecg', 'exang', 'slope', 'ca', 'thal']

# Set up the figure size
plt.figure(figsize=(15, 10))

# Loop through each categorical feature
for i, feature in enumerate(categorical_features):
    plt.subplot(2, 4, i + 1)

    # Create a contingency table for counts
    crosstab = pd.crosstab(refinal[feature], refinal['target'])

    # Create stacked bar plot using pd.crosstab
    crosstab.plot(kind='bar', stacked=True, ax=plt.gca(), color=['#ff9999','grey'], width=0.8)

    # Set plot title and labels
    plt.title(f'{feature} vs Target')
    plt.xlabel(feature)
    plt.ylabel('Count')

    # Rotate x-axis labels for readability
    plt.xticks(rotation=45)

    # Add counts to the bars
    for p in plt.gca().patches:
        height = p.get_height()
        width = p.get_width()
        x = p.get_x() + width / 2
        y = p.get_y() + height / 2

        # Annotate the count on the bar
        plt.text(x, y, f'{int(height)}', ha='center', va='center', fontsize=10, fontweight='bold', color='white')

# Adjust layout to prevent overlap
plt.tight_layout()

# Show the plots
plt.show()

plt.figure(figsize=(6, 4))
colors=["green","purple"]
cx=sns.countplot(data=refinal, x='target', palette=colors)

for bar in cx.patches:
    cx.text(bar.get_x() + bar.get_width() / 2,
            bar.get_height(),
            int(bar.get_height()),
            ha='center',
            va='bottom')

plt.title("Target Variable Distribution")
plt.xlabel("Target")
plt.ylabel("Count")
plt.show()

#For creating a figure with specified size
plt.figure(figsize=(20,20))

# Adjusting the space between subplots
plt.subplots_adjust(hspace=0.5)  # Increase the vertical space between subplots

#Configuration of subplots
plt.subplot(5,1,1)

#plotting scatterplot based on stress level and BMI category
pic1=sns.scatterplot(x='age',y='trestbps',data =refinal,hue='sex',marker="o",s=70)
plt.title('Age vs Blood Pressure by Sex', fontsize=20, fontweight='bold', color='purple')
#Adding Legend
plt.legend(fontsize=15)
#Set the X,y axis labels
plt.xlabel("Age",fontsize=19,fontweight="bold",color="red")
plt.ylabel("Blood pressure",fontsize=19,fontweight="bold",color="red")

#Set the fontsize for the X,Y tick labels
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)



#Configuration for second subplots
plt.subplot(5,1,2)

#plotting scatterplot based on Physical Activity level and BMI category
pic2=sns.scatterplot(x='sex',y='cp',data =refinal,hue='target',marker="*",s=220,palette='magma')
plt.title('Sex vs Chest Pain by Target', fontsize=20, fontweight='bold', color='purple')
#Adding Legend
plt.legend(fontsize=15)
#Set the X,y axis labels
plt.xlabel("Sex",fontsize=19,fontweight="bold",color="green")
plt.ylabel("Chest Pain Level",fontsize=19,fontweight="bold",color="green")

#Set the fontsize for the X,Y tick labels
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)


#Configuration for Third subplots
plt.subplot(5,1,3)

#plotting scatterplot based on Quality of sleep and Occupation
pic3=sns.scatterplot(x='ca',y='trestbps',data =refinal,hue='target',marker="p",s=70,palette='inferno')
plt.title('Ca vs Blood Pressure by target', fontsize=20, fontweight='bold', color='purple')
#Adding Legend
plt.legend(fontsize=15)
#Set the X,y axis labels
plt.xlabel("Number of major vessel(CA)",fontsize=19,fontweight="bold",color="red")
plt.ylabel("Blood pressure",fontsize=19,fontweight="bold",color="red")

#Set the fontsize for the X,Y tick labels
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)



#Configuration for fourth subplots
plt.subplot(5,1,4)

custom_palette = {0: 'red', 1: 'black'}
#plotting scatterplot based on stress level and Occupation
pic4=sns.scatterplot(x='age',y='chol',data =refinal,hue='target',marker="^",s=120 ,palette=custom_palette)
plt.title('Age vs Cholestrol by Target', fontsize=20, fontweight='bold', color='purple')
#Adding Legend
plt.legend(fontsize=15)
#Set the X,y axis labels
plt.xlabel("age",fontsize=19,fontweight="bold",color="green")
plt.ylabel("chol",fontsize=19,fontweight="bold",color="green")

#Set the fontsize for the X,Y tick labels
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)



#Configuration for fourth subplots
plt.subplot(5,1,5)

#plotting scatterplot based on Physical Activity level and BMI category
pic5=sns.scatterplot(x='sex',y='age',data =refinal,hue='target',marker="s",s=220,color='red')

#Adding Legend
plt.legend(fontsize=15)

#Set the X,y axis labels
plt.xlabel("Sex",fontsize=19,fontweight="bold",color="green")
plt.ylabel("Age",fontsize=19,fontweight="bold",color="green")
plt.title('Sex vs Age by Target', fontsize=20, fontweight='bold', color='purple')
#Set the fontsize for the X,Y tick labels
plt.xticks(fontsize=16)
plt.yticks(fontsize=16)


#Adding legend
plt.legend(fontsize=16)
print(pic1)
print(pic2)
print(pic3)
print(pic4)
print(pic5)

# Implementing one-hot encoding on the specified categorical features
refinal_encoded = pd.get_dummies(refinal, columns=['cp', 'restecg', 'thal'])

# Convert the rest of the categorical variables that don't need one-hot encoding to integer data type
features_to_convert = ['sex', 'fbs', 'exang', 'slope', 'ca', 'target']
for feature in features_to_convert:
    refinal_encoded[feature] = refinal_encoded[feature].astype(int)

refinal_encoded.dtypes

refinal_encoded.head()

# copy of cleaned data
refinenco = cleaned_refinal1.copy()

#One-hot encode categorical features that have multiple categories
refinenco = pd.get_dummies(refinenco, columns=['cp', 'restecg', 'thal'])

# Convert remaining categorical features to integers
features_to_convert = ['sex', 'fbs', 'exang', 'slope', 'ca', 'target']
for feature in features_to_convert:
    refinenco[feature] =refinenco[feature].astype(int)

# Defining X and y
X = refinenco.drop('target', axis=1)
y = refinenco['target']

# Step 4: Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# Step 5: Initialize and train Random Forest
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Step 6: Make predictions
y_pred = rf_model.predict(X_test)

# Step 7: Evaluate the model
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))
print("\nAccuracy Score: {:.2f}%".format(accuracy_score(y_test, y_pred) * 100))



